package musig2

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"github.com/ellemouton/schnorr"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestNonceGen(t *testing.T) {
	tests := []struct {
		rand     string
		sk       string
		pk       string
		aggPk    string
		msg      string
		extraIn  string
		expected string
	}{
		{
			rand:     "0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F",
			sk:       "0202020202020202020202020202020202020202020202020202020202020202",
			pk:       "024D4B6CD1361032CA9BD2AEB9D900AA4D45D9EAD80AC9423374C451A7254D0766",
			aggPk:    "0707070707070707070707070707070707070707070707070707070707070707",
			msg:      "0101010101010101010101010101010101010101010101010101010101010101",
			extraIn:  "0808080808080808080808080808080808080808080808080808080808080808",
			expected: "B114E502BEAA4E301DD08A50264172C84E41650E6CB726B410C0694D59EFFB6495B5CAF28D045B973D63E3C99A44B807BDE375FD6CB39E46DC4A511708D0E9D2024D4B6CD1361032CA9BD2AEB9D900AA4D45D9EAD80AC9423374C451A7254D0766",
		},
		{
			rand:     "0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F",
			sk:       "0202020202020202020202020202020202020202020202020202020202020202",
			pk:       "024D4B6CD1361032CA9BD2AEB9D900AA4D45D9EAD80AC9423374C451A7254D0766",
			aggPk:    "0707070707070707070707070707070707070707070707070707070707070707",
			extraIn:  "0808080808080808080808080808080808080808080808080808080808080808",
			expected: "E862B068500320088138468D47E0E6F147E01B6024244AE45EAC40ACE5929B9F0789E051170B9E705D0B9EB49049A323BBBBB206D8E05C19F46C6228742AA7A9024D4B6CD1361032CA9BD2AEB9D900AA4D45D9EAD80AC9423374C451A7254D0766",
		},
		{
			rand:     "0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F",
			sk:       "0202020202020202020202020202020202020202020202020202020202020202",
			pk:       "024D4B6CD1361032CA9BD2AEB9D900AA4D45D9EAD80AC9423374C451A7254D0766",
			aggPk:    "0707070707070707070707070707070707070707070707070707070707070707",
			msg:      "2626262626262626262626262626262626262626262626262626262626262626262626262626",
			extraIn:  "0808080808080808080808080808080808080808080808080808080808080808",
			expected: "3221975ACBDEA6820EABF02A02B7F27D3A8EF68EE42787B88CBEFD9AA06AF3632EE85B1A61D8EF31126D4663A00DD96E9D1D4959E72D70FE5EBB6E7696EBA66F024D4B6CD1361032CA9BD2AEB9D900AA4D45D9EAD80AC9423374C451A7254D0766",
		},
		{
			rand:     "0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F",
			sk:       "null",
			pk:       "02F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9",
			aggPk:    "null",
			msg:      "null",
			extraIn:  "null",
			expected: "89BDD787D0284E5E4D5FC572E49E316BAB7E21E3B1830DE37DFE80156FA41A6D0B17AE8D024C53679699A6FD7944D9C4A366B514BAF43088E0708B1023DD289702F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9",
		},
	}

	for i, test := range tests {
		name := fmt.Sprintf("%d", i)
		t.Run(name, func(t *testing.T) {
			pkBytes := parseHexStr(t, test.pk)

			pk, err := schnorr.ParsePlainPubKey(pkBytes)
			require.NoError(t, err)

			var opts []NonceGenOption

			if test.rand != "null" {
				var rand [32]byte
				copy(rand[:], parseHexStr(t, test.rand))

				opts = append(opts, WithRandBytes(rand))
			}

			if test.sk != "null" {
				sk, err := schnorr.ParsePrivKeyHexString(
					test.sk,
				)
				require.NoError(t, err)

				opts = append(opts, WithOptionSecretKey(sk))
			}

			if test.aggPk != "null" {
				aggPk, err := schnorr.ParseXOnlyPubKeyHexString(
					test.aggPk,
				)
				require.NoError(t, err)

				opts = append(opts, WithOptionAggKey(aggPk))
			}

			if test.msg != "null" {
				opts = append(opts, WithOptionMessage(
					parseHexStr(t, test.msg)),
				)
			}

			if test.extraIn != "null" {
				opts = append(opts, WithOptionExtraIn(
					parseHexStr(t, test.extraIn)),
				)
			}

			nonce, err := NonceGen(pk, opts...)
			require.NoError(t, err)

			exp, err := hex.DecodeString(test.expected)
			require.NoError(t, err)

			require.True(t,
				bytes.Equal(nonce.SecNonce.Bytes(), exp))
		})
	}
}

func TestNonceAgg(t *testing.T) {
	pnonceStrs := []string{
		"020151C80F435648DF67A22B749CD798CE54E0321D034B92B709B567D60A42E66603BA47FBC1834437B3212E89A84D8425E7BF12E0245D98262268EBDCB385D50641",
		"03FF406FFD8ADB9CD29877E4985014F66A59F6CD01C0E88CAA8E5F3166B1F676A60248C264CDD57D3C24D79990B0F865674EB62A0F9018277A95011B41BFC193B833",
		"020151C80F435648DF67A22B749CD798CE54E0321D034B92B709B567D60A42E6660279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798",
		"03FF406FFD8ADB9CD29877E4985014F66A59F6CD01C0E88CAA8E5F3166B1F676A60379BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798",
		"04FF406FFD8ADB9CD29877E4985014F66A59F6CD01C0E88CAA8E5F3166B1F676A60248C264CDD57D3C24D79990B0F865674EB62A0F9018277A95011B41BFC193B833",
		"03FF406FFD8ADB9CD29877E4985014F66A59F6CD01C0E88CAA8E5F3166B1F676A60248C264CDD57D3C24D79990B0F865674EB62A0F9018277A95011B41BFC193B831",
		"03FF406FFD8ADB9CD29877E4985014F66A59F6CD01C0E88CAA8E5F3166B1F676A602FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30",
	}

	tests := []struct {
		indices   []int
		expected  string
		expectErr bool
	}{
		{
			indices:  []int{0, 1},
			expected: "035FE1873B4F2967F52FEA4A06AD5A8ECCBE9D0FD73068012C894E2E87CCB5804B024725377345BDE0E9C33AF3C43C0A29A9249F2F2956FA8CFEB55C8573D0262DC8",
		},
		{
			indices:  []int{2, 3},
			expected: "035FE1873B4F2967F52FEA4A06AD5A8ECCBE9D0FD73068012C894E2E87CCB5804B000000000000000000000000000000000000000000000000000000000000000000",
		},
		{
			indices:   []int{0, 4},
			expectErr: true,
		},
		{
			indices:   []int{5, 1},
			expectErr: true,
		},
		{
			indices:   []int{6, 1},
			expectErr: true,
		},
	}

	for _, test := range tests {
		n1, err := ParsePubNonce(parseHexStr(t, pnonceStrs[test.indices[0]]))
		if err != nil && test.expectErr {
			continue
		}
		require.NoError(t, err)

		n2, err := ParsePubNonce(parseHexStr(t, pnonceStrs[test.indices[1]]))
		if err != nil && test.expectErr {
			continue
		}
		require.NoError(t, err)

		n := NonceAgg([]*PubNonce{n1, n2})

		expectedRes := parseHexStr(t, test.expected)

		require.True(t, bytes.Equal(expectedRes, n.Bytes()))
	}
}

func parseHexStr(t *testing.T, s string) []byte {
	b, err := hex.DecodeString(s)
	require.NoError(t, err)

	return b
}
