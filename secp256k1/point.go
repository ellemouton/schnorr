package secp256k1

import (
	"github.com/ellemouton/schnorr/ellipticcurve"
	"math/big"
)

const (
	n  = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"
	gx = "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"
	gy = "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8"
)

var (
	// G is the generator point of the curve.
	G *Point

	// N is the order of the group generated by G.
	N *big.Int
)

// Point is a point on the secp256k1 curve.
type Point struct {
	*ellipticcurve.Point
}

// NewPoint constructs a new Point.
func NewPoint(x, y *FieldElement) (*Point, error) {
	p, err := ellipticcurve.NewPoint(x.Element, y.Element, Curve)
	if err != nil {
		return nil, err
	}

	return &Point{p}, nil
}

// NewInfinityPoint constructs a new Point at infinity.
func NewInfinityPoint() *Point {
	p := ellipticcurve.NewInfinityPoint(Curve)

	return &Point{p}
}

// Mul does scalar multiplication on the point.
func (p *Point) Mul(c *big.Int) *Point {
	var coef big.Int
	coef.Mod(c, N)

	point, err := p.Point.Mul(&coef)
	if err != nil {
		// Mul will only ever error if the points being added are not
		// on the same curve or the elements of the points are on
		// different finite fields. Point guarantees that the same curve
		// and same finite field.
		panic(err)
	}

	return &Point{point}
}

// Copy returns a copy of the Point.
func (p *Point) Copy() *Point {
	return &Point{
		Point: p.Point.Copy(),
	}
}

// Equal returns true if Points are the same coordinate on the same curve.
func (p *Point) Equal(o *Point) bool {
	return p.Point.Equal(o.Point)
}

// Add adds the two points together.
func (p *Point) Add(o *Point) *Point {
	res, err := p.Point.Add(o.Point)
	if err != nil {
		// Add will only ever error if the points being added are not
		// on the same curve or the elements of the points are on
		// different finite fields. Point guarantees that the same
		// curve and same finite field.
		panic(err)
	}

	return &Point{res}
}

func pointInit() {
	var ok bool
	N, ok = new(big.Int).SetString(n, 16)
	if !ok {
		panic("invalid hex: " + n)
	}

	gX, ok := new(big.Int).SetString(gx, 16)
	if !ok {
		panic("invalid hex: " + gx)
	}

	gY, ok := new(big.Int).SetString(gy, 16)
	if !ok {
		panic("invalid hex: " + gy)
	}

	gXFe, err := NewFieldElement(gX)
	if err != nil {
		panic("could not make FieldElement for Gx: " + err.Error())
	}

	gYFe, err := NewFieldElement(gY)
	if err != nil {
		panic("could not make FieldElement for Gy: " + err.Error())
	}

	G, err = NewPoint(gXFe, gYFe)
	if err != nil {
		panic("could not init generator point: " + err.Error())
	}
}
